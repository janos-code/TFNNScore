% Solve a Pattern Recognition Problem with a Neural Network
% Script generated by Neural Pattern Recognition app
% Created 21-Apr-2015 13:23:01
%
% This script assumes these variables are defined:
%
%   p - input data.
%   t - target data.

% load('coulombvdWreducegoodbind.mat')
load('testdatavdwcoulomb.mat')
lv_out = [40    43   111   112   114   130   138   145   146   208   209   211   227   100   240 ...
   131    14   165    90    91    41    73   186    89    56    93    23   125   175   103 ...
   174   137     2    76    67   210   147    81    68   117   132   188   128   173   196 ...
   105    59   239   113    71   166    99   178   164   126   228     5    42    38 ...
   153   141    79   187   230   176   144    92    45   133   229   214    12    46    94 ...
   21   118    44 ...
   190   108    95    61   170 ...
   36    27   172 ...
   198 ...
   140 ...
   216   205   152    72    82    37 ...
   169   182   224    32   167   107    53 ...
   83 ...
   31    88    62 ...
   18    35   222   120   189   159 ...
   39];

% lv_out = [2    14    23    27    36    40    41    42    43 ...
%           45    67    68    89    90    99   108   111   112 ...
%           113   114   130   131   137   138   142   145   146 ...
%           147   164   173   184   196   197   208   209   210 ...
%           211   227   239    37   100   103   152   198    74 ...
%            81    133   165   166   178   240    175    91   132 ...  
%           186   230     5    12    18    56    69    71    73 ...   
%           76    79    107   117   125   126   128   144   153 ...  
%           172   188   204   205   220     6    21    35    46 ...   
%            52    59    75    93    95   105   149   174   176 ...  
%           187   200   214   222   228  229   237     1     3 ...    
%             7    15    25    30    31    38    58   62    63 ...   
%            88    92    94   115   121   134   135  140   141 ...  
%           143   150   161   170   190   216   223  232   242 ...
%             8    11    28    29    49    61    66    80    82 ...
%            83    87    97   104   110   148   154   155   158 ...
%           167   189   192   194   217   219   225   231   238 ...
%           234    10    24    34    48    50    65    70    72 ...    
%            78   101   102   109   118   119   122   181   185 ...  
%           202   206   207   226   235   236   241   244    22 ...   
%            32    51    54    60    96   159   162   168   169 ...  
%           177   179   183   193   199   201    13    57    77 ...   
%            85   116   123   124   139   151   157   163   171 ...  
%           182   203   212   213   215   218   221     4    16 ...   
%           19    20    33    55    64    86   106    136   160 ...  
%           191   195   243    9    17    26    39    44    47  ...  
%           53    84    98    120   127   129   156   180];
%lv_out = [];
% lv_out = [ 2    14    23    27    37    40    42    43    45    67    68 ...
% 76    81    90    99   100   103   108   111   112   113   114 ...
% 128   130   131   132   137   138   142   145   146   147   152 ...
% 164   173   178   184   196   197   198   200   205   208   209 ...
% 211   227   239  5    18    36    41    79   133   166   172   ...
% 204   210   240  73    89   165   175    56   107   153   186 ...
% 230    6   188    105   91   117   174];

tic
p_orig = p;
p_orig(lv_out,:)=[];
t_orig = t;
x = p;
[r,q] = size(x);
ew = ones(size(t));
%ew(ind_missClass) = 1;
ew_orig = ew;

num_networks = 20;
num_montecarlo = 50;
frac = 0.999;

% Choose a Training Function
% For a list of all training functions type: help nntrain
% 'trainlm' is usually fastest.
% 'trainbr' takes longer but may be better for challenging problems.
% 'trainscg' uses less memory. Suitable in low memory situations.
trainFcn = 'trainscg';  % Scaled conjugate gradient backpropagation.

% Create a Pattern Recognition Network
hiddenLayerSize = 5;
net = patternnet(hiddenLayerSize);

% Choose Input and Output Pre/Post-Processing Functions
% For a list of all processing functions type: help nnprocess
net.input.processFcns = {'removeconstantrows','mapminmax'};
net.output.processFcns = {};

% Setup Division of Data for Training, Validation, Testing
% For a list of all data division functions type: help nndivide
net.divideFcn = 'dividerand';  % Divide data randomly
net.divideMode = 'sample';  % Divide up every sample
% net.divideParam.trainRatio = 70/100;
% net.divideParam.valRatio = 15/100;
% net.divideParam.testRatio = 15/100;
net.divideParam.trainRatio = 70/85;
net.divideParam.valRatio = 15/85;
net.divideParam.testRatio = 0/100;
testRatio = 15/100;

% Choose a Performance Function
% For a list of all performance functions type: help nnperformance
net.performFcn = 'crossentropy';  % Cross-Entropy
net.trainParam.max_fail = 20;
% Choose Plot Functions
% For a list of all plot functions type: help nnplot
net.plotFcns = {'plotperform','plottrainstate','ploterrhist', ...
    'plotconfusion', 'plotroc'};

percentErrors = zeros(1,num_montecarlo);
cmind = cell(1,num_montecarlo);
test_ind = cell(1,num_montecarlo);
net_com_mc = cell(1,num_montecarlo);
for j = 1:num_montecarlo,
    x = p_orig;
    t = t_orig;
    ew = ew_orig;
    net_committee = cell(1,num_networks);
    tr_comm = cell(1,num_networks);
    
    % Remove testRatio of the data for testing
    randInd = randperm(q);
    testInd = randInd(1:round(q*testRatio));
    test_ind{j} = testInd;
    xtest = x(:,testInd);
    ttest = t(:,testInd);
    ewtest = ew(:,testInd);
    x(:,testInd) = [];
    t(:,testInd) = [];
    ew(:,testInd) = [];

    for i=1:num_networks,
        net_committee{i} = net;
        net_committee{i} = init(net_committee{i});
        [net_committee{i},tr_comm{i}] = train(net_committee{i},x,t,[],[],ew);
    end
    net_com_mc{j} = net_committee;
    % Train the Network
    %[net,tr] = train(net,x,t);

    ytottest = [];
    % Test the Network on the test set, and find the percent error
    for i=1:num_networks,
        ytest = net_committee{i}(xtest);
        ytottest = [ytottest;(ytest(1,:)-ytest(2,:))>0];
    end
    decisiontest = sum(ytottest)>=(num_networks/2);
    
    percentErrors(j) = sum(decisiontest~=ttest(1,:))/length(decisiontest);
    
    ytot = [];
    % Test the Network on the full data set, and find the missclassified
    % data
    for i=1:num_networks,
        y = net_committee{i}(p_orig);
        ytot = [ytot;(y(1,:)-y(2,:))>0];
    end
    decision = sum(ytot)>=(num_networks/2);
    [~,~,cmind{j}] = confusion(t_orig(1,:),decision);
    j;
end
save vdwmc10_28_16;
toc
num_networks
hiddenLayerSize